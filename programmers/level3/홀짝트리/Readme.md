# 풀이 과정
1. 처음에 완탐으로 생각! => 시간 복잡도: O(400000 * 400000) => 불가능
2. 중복이 존재함을 발견
    - 이전 노드, 현재 노드에 대해서 중복이 존재함을 발견
    - 완전 탐색(dfs) + dp 를 통해 문제를 해결하려고 함
    - 메모리제이션을 하려고 했으나 메모리 공간 크기가 문제임
        - 노드의 인덱스는 1 부터 1000000 이다. 2차원 배열이 필요한데 그러면 메모리 공간이 4B * 1000000 * 1000000
3. 새로운 아이디어가 필요!
    - 포레스트 일 때 각 노드에 대해서 홀수, 짝수, 역홀수, 역짝수 트리를 구분할 수 있다.
        짝수 노드 + 연결된 엣지 수 짝수 => 짝수 노드
        홀수 노드 + 연결된 엣지 수 홀수 => 홀수 노드
        짝수 노드 + 연결된 엣지 수 홀수 => 역짝수 노드
        홀수 노드 + 연결된 엣지 수 짝수 => 역홀수 노드

    - 만약, 루트 노드가 결정되면 각 노드는 다음처럼 바뀐다.
        원래, 루트 노드의 경우는 그대로이다.
        루트 노드가 아닌 노드들은 역이 된다.
        짝수 노드 -> 역짝수 노드
        홀수 노드 -> 역홀수 노드
        역짝수 노드 -> 짝수 노드
        역홀수 노드 -> 홀수 노드

    - 홀수 노드 + 짝수 노드 끼리 모여 있다면 그 트리는 홀짝수 노드이다. 반대로 역홀수 노드 + 역짝수 노드끼리 모여 있다면 그 트리는 역 홀짝수 노드이다.

4. 하나의 트리에 대해서만 한번만 탐색하면 된다. 여러 번 탐색하지 않기 위해서는 각 노드에 대하여 방문 여부를 확인하면 되지 않을까 싶다.
    - 각 트리를 순회할 때 홀짝수 노드 혹은 역홀짝수 노드를 카운트 한다.
    - 홀짝수 노드 혹은 역홀짝수 노드가 1이라면 홀짝수 트리 혹은 역홀짝수 트리를 1로 만들 수 있는 것이다.
    

